
**JWT (JSON Web Token)** is a standardized format for sending cryptographically signed JSON data. Often used for AuthN and AuthZ.

It's formed by 3 parts:
- **Header**: base64-encoded, cryptographically clear. Here there are fields like the algorithm.
- **Payload**: base64-encoded, can be cryptographically clear or not. Here there are fields like the token issuer, the expiration date, user attributes. 
- **Signature**: generated by hashing the header and payload. In some cases, servers also encrypt the resulting hash. Either way, this process involves a secret signing key.

The JWT specification is actually very limited, so it's usually extended by both the **JSON Web Signature (JWS)** and **JSON Web Encryption (JWE)** specifications, which define concrete ways of actually implementing JWTs.

In other words, a JWT is usually either a JWS or JWE token. When people use the term "JWT", they almost always mean a JWS token. JWEs are very similar, except that the actual contents of the token are encrypted rather than just encoded.

In JWS the header and payload are signed by **HMAC** (hash-based message authentication code) or **RSA** (public/private key pair).

## What are JWT attacks?

JWT attacks involve a user sending modified JWTs to the server in order to achieve a malicious goal. Typically, this goal is to bypass authentication and access controls by impersonating another user who has already been authenticated.

JWT vulnerabilities typically arise due to flawed JWT handling within the application itself.

## Vulnerabilities and Labs

- **Accepting tokens with no signature**
- **Accepting tokens with tampered algorithm**
- **Weak encryption keys**
- **Misunderstand symmetric and asymmetric encryption**
- **Using JWS and thinking data is not readable**

### Accepting arbitrary signatures

JWT libraries typically provide one method for verifying tokens and another that just decodes them. For example, the Node.js library `jsonwebtoken` has `verify()` and `decode()`.

Occasionally, developers confuse these two methods and only pass incoming tokens to the `decode()` method. This effectively means that the application doesn't verify the signature at all.

###### Lab: JWT authentication bypass via unverified signature

The server doesn't verify the signature of any JWTs that it receives.

Take the JWT and decode it using https://token.dev/ or https://jwt.io/:

```json
{
  "iss": "portswigger",
  "exp": 1734961397,
  "sub": "wiener"
}
```

and change `"wiener"` to `"administrator"`. Then copy and paste the new encoded JWT in the session browser and delete user carlos.

### Accepting tokens with no signature

The JWT header contains an `alg` parameter which tells the server which algorithm was used to sign the token and, therefore, which algorithm it needs to use when verifying the signature.

JWTs can also be left unsigned. In this case, the `alg` parameter is set to `none`, which indicates a so-called *"unsecured JWT"*. Servers usually reject tokens with no signature. However, as this kind of filtering relies on string parsing, you can sometimes bypass these filters using classic obfuscation techniques, such as mixed capitalization and unexpected encodings.

###### Lab: JWT authentication bypass via flawed signature verification

The server is insecurely configured to accept unsigned JWTs.

```json
{
  "kid": "2779b00d-584a-4905-b3cc-e025c5955478",
  "alg": "RS256"
}
{
  "iss": "portswigger",
  "exp": 1734961397,
  "sub": "wiener"
}
```

Change `"RS256"` to `"none"` and `"wiener"` to `"administrator"`. Then copy and paste the new JWT in the session browser and delete user carlos.


## Brute-forcing secret keys

Some signing algorithms, such as HS256 (HMAC + SHA-256), use an arbitrary, standalone string as the secret key. Just like a password, it's crucial that this secret can't be easily guessed or brute-forced by an attacker.

When implementing JWT applications, developers sometimes make mistakes like forgetting to change default or placeholder secrets.

### Brute-forcing secret keys using hashcat

You just need a valid, signed JWT from the target server and a [wordlist of well-known secrets](https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list). You can then run the following command, passing in the JWT and wordlist as arguments:

```bash
hashcat -a 0 -m 16500 <jwt> <wordlist>
```

Once you have identified the secret key, you can use it to generate a valid signature for any JWT header and payload that you like.

###### Lab: JWT authentication bypass via weak signing key

Decode and tamper the JWT, then use hashcat to brute-force the secret key and encode again the tampered JWT.

## JWT header parameter injections

According to the JWS specification, only the `alg` header parameter is mandatory. In practice, however, JWT headers (also known as JOSE headers) often contain several other parameters. The following ones are of particular interest to attackers:

- `jwk` (JSON Web Key) - Provides an embedded JSON object representing the key.
- `jku` (JSON Web Key Set URL) - Provides a URL from which servers can fetch a set of keys containing the correct key.
- `kid` (Key ID) - Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching `kid` parameter.

These user-controllable parameters each tell the server which key to use when verifying the signature.

### Injecting self-signed JWTs via the jwk parameter

This is an example of `jwk` header:

```json
{ 
	"kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG", 
	"typ": "JWT", 
	"alg": "RS256", 
	"jwk": { 
		"kty": "RSA", 
		"e": "AQAB", 
		"kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG", 
		"n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m" 
	}
}
```

Ideally, servers should only use a limited whitelist of public keys to verify JWT signatures. However, misconfigured servers sometimes use any key that's embedded in the `jwk` parameter.

You can exploit this behavior by signing a modified JWT using your own RSA private key, then embedding the matching public key in the `jwk` header.

###### Lab: JWT authentication bypass via jwk header injection

The server supports the `jwk` parameter in the JWT header. This is sometimes used to embed the correct verification key directly in the token. However, it doesn't check whether the provided key came from a trusted source. Hence, we can inject a malicious `jwk` parameter.

- The lab description tells us that we can provide keys.  We want to use the one used by https://token.dev/.
- Copy the public key and paste it in https://jwkset.com/generate. Copy the Key ID from the JWT token, select the correct algorithm and Generate. 
- Add the "jwk" entry to the header of the JWT token, use the generated content as the value.  
- Make yourself an administrator and delete carlos.


### Injecting self-signed JWTs via the jku parameter

Instead of embedding public keys directly using the `jwk` header parameter, some servers let you use the `jku` (JWK Set URL) header parameter to reference a JWK Set containing the key. When verifying the signature, the server fetches the relevant key from this URL.

A **JWK Set** is a JSON object containing an array of JWKs representing different keys, like the one below:

```json
{ 
"keys": [ 
	{ 
		"kty": "RSA", 
		"e": "AQAB", 
		"kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab", 
		"n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
	}, 
	{ 
		"kty": "RSA", 
		"e": "AQAB", 
		"kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA", 
		"n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
	} 
] 
}
```

JWK Sets like this are sometimes exposed publicly via a standard endpoint.

###### Lab: JWT authentication bypass via jku header injection

The server supports the `jku` parameter in the JWT header. However, it doesn't check whether the provided URL belongs to a trusted domain before fetching the key.

- We can specify a URL containing keys via the "jku" header.  
- Analyze the token with https://token.dev/ and note that RS256 is used. We can select JWKs URI to obtain a link to a JSON file containing public keys used by https://token.dev/.  
- Download the file and copy its content to the exploit server.  
- Unselect the "JWKs URI" option and modify the "kid" header to "test-rsa" (the key id used by https://token.dev/) and the "sub" to "administrator".  
- Add the "jku" header, pointing to the exploit server.  
- Verify that the JWT token is valid (also check the log to see that the server fetched the keys from the exploit server).
- Make yourself an administrator and delete carlos.

At the end we'll have a JWT (to be encoded) like this:

```json
{
  "kid": "test-rsa",
  "alg": "RS256",
  "jku": "https://exploit-0a03009c04da115481fea66f01a700bf.exploit-server.net/exploit"
}
{
  "iss": "portswigger",
  "exp": 1735322169,
  "sub": "administrator"
}

```


### Injecting self-signed JWTs via the kid parameter

The header of a JWT may contain a `kid` (Key ID) parameter, which helps the server identify which key to use when verifying the signature.

The JWS specification doesn't define a concrete structure for this ID - it's just an arbitrary string of the developer's choosing. For example, they might use the `kid` parameter to point to a particular entry in a database, or even the name of a file.

If this parameter is also vulnerable to directory traversal, an attacker could potentially force the server to use an arbitrary file from its filesystem as the verification key.

If this parameter is also vulnerable to directory traversal, an attacker could potentially force the server to use an arbitrary file from its filesystem as the verification key.

```json
{ 
	"kid": "../../path/to/file", 
	"typ": "JWT", 
	"alg": "HS256", 
	"k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc" 
}
```

This is especially dangerous if the server also supports JWTs signed using a symmetric algorithm. In this case, an attacker could potentially point the `kid` parameter to a predictable, static file, then sign the JWT using a secret that matches the contents of this file.

One of the simplest methods is to use `/dev/null`, which is present on most Linux systems. As this is an empty file, reading it returns an empty string. Therefore, signing the token with an empty string will result in a valid signature.

###### JWT authentication bypass via kid header path traversal  
  
- The kid is actually interpreted as a file and the reading suggests to use path traversal to point to `/dev/null`.
- Analyze the token with https://jwt.io/ (as https://token.dev/ doesn't work well with empty keys). Change the key in "verify signature" to anything, then back to empty string (so that the JWT is updated).  
- Change the kid to `../../../dev/null` (or similar).  
- Verify that you are still authenticated as wiener.
- Make yourself an administrator and delete carlos.


## Prevention

- Use an up-to-date library for handling JWTs and make sure your developers fully understand how it works.
- Make sure that you perform robust signature verification on any JWTs that you receive and account for edge-cases such as JWTs signed using unexpected algorithms.
- Enforce a strict whitelist of permitted hosts for the `jku` header.
- Make sure that you're not vulnerable to path traversal or SQL injection via the `kid` header parameter.
